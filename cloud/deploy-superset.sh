#!/bin/bash
set -euo pipefail

echo "Generating random passwords and secret keys for Superset..."

# Generate random strings for secrets
# SECRET_KEY and GUEST_TOKEN_JWT_SECRET are recommended to be base64-encoded and long (e.g., 42 chars)
SUPERSET_SECRET_KEY=$(openssl rand -base64 42)
GUEST_TOKEN_JWT_SECRET=$(openssl rand -base64 42)

# Database and Redis passwords (alphanumeric with underscore, 20 chars long)
DB_PASSWORD=$(head /dev/urandom | tr -dc A-Za-z0-9_ | head -c 20)
REDIS_PASSWORD=$(head /dev/urandom | tr -dc A-Za-z0-9_ | head -c 20)

# Superset Admin password (alphanumeric with underscore, 16 chars long)
ADMIN_PASSWORD=$(head /dev/urandom | tr -dc A-Za-z0-9_ | head -c 16)

# Websocket JWT Secret (if websockets are enabled)
WEBSOCKET_JWT_SECRET=$(openssl rand -base64 32)

# save deployment secrets in a file
CREDENTIALS_FILE_PREFIX=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 13; echo)
CREDENTIALS_FILE="${CREDENTIALS_FILE_PREFIX}-deployment-secrets.json"
echo "SUPERSET_SECRET_KEY: ${SUPERSET_SECRET_KEY}" > $CREDENTIALS_FILE
echo "GUEST_TOKEN_JWT_SECRET: ${GUEST_TOKEN_JWT_SECRET}" >> $CREDENTIALS_FILE
echo "DB_PASSWORD: ${DB_PASSWORD}" >> $CREDENTIALS_FILE
echo "REDIS_PASSWORD: ${REDIS_PASSWORD}" >> $CREDENTIALS_FILE
echo "ADMIN_PASSWORD: ${ADMIN_PASSWORD}" >> $CREDENTIALS_FILE
echo "WEBSOCKET_JWT_SECRET: ${WEBSOCKET_JWT_SECRET}" >> $CREDENTIALS_FILE


# Create a temporary YAML file with the generated secrets
TEMP_SECRETS_FILE="temp-superset-generated-secrets.yaml"

cat <<EOF > "$TEMP_SECRETS_FILE"
# This file is auto-generated by deploy-superset.sh and contains sensitive information.
# It should NOT be committed to version control.
extraSecretEnv:
  SUPERSET_SECRET_KEY: '$SUPERSET_SECRET_KEY'
configOverrides:
  enable_embeding: |
      # This will make sure the redirect_uri is properly computed, even with SSL offloading
      ENABLE_PROXY_FIX = True

      FEATURE_FLAGS = {
          "EMBEDDED_SUPERSET": True,
          "DYNAMIC_PLUGINS": True
      }

      GUEST_ROLE_NAME = "EVERSE"
      GUEST_TOKEN_JWT_SECRET = "$GUEST_TOKEN_JWT_SECRET"
      GUEST_TOKEN_JWT_ALGO = "HS256"
      GUEST_TOKEN_HEADER_NAME = "X-GuestToken"
      GUEST_TOKEN_JWT_EXP_SECONDS = 300 # 5 minutes

  # Retain existing CORS configuration
  enable_cors: |
      ENABLE_CORS = True
      CORS_OPTIONS = {
          "supports_credentials": True,
          "allow_headers": "*",
          "expose_headers": "*",
          "resources": "*",
          "origins": ["http://localhost:4200","http://localhost:3000"]
      }

supersetNode:
  connections:
    db_pass: '$DB_PASSWORD'
init:
  adminUser:
    password: '$ADMIN_PASSWORD'
postgresql:
  auth:
    password: '$DB_PASSWORD' # Ensure this matches supersetNode.connections.db_pass
redis:
  auth:
    enabled: true # IMPORTANT: Enabling Redis authentication for security
    password: '$REDIS_PASSWORD'
supersetWebsockets:
  # This is disabled by default in your dashverse-values.yaml,
  # but including the secret generation for completeness if you enable it later.
  enabled: false
  config:
    jwtSecret: '$WEBSOCKET_JWT_SECRET'
EOF

echo "Generated temporary secrets file: $TEMP_SECRETS_FILE"

# Deploy Superset using Helm
# The --values flag order matters: later files override earlier ones.
# So, temp-superset-generated-secrets.yaml will override conflicting values from dashverse-values-with-ingress.yaml
echo "Starting Helm deployment..."
helm upgrade --install superset superset/superset \
    --values dashverse-values-with-ingress.yaml \
    --values "$TEMP_SECRETS_FILE" \
    --namespace superset --create-namespace \
    --debug --cleanup-on-fail

# Display the generated admin password (for initial login)
echo ""
echo "=========================================================="
echo "  SUPERSET ADMIN USER PASSWORD (for 'admin' user): "
echo "  $ADMIN_PASSWORD"
echo "  PLEASE SAVE THIS SECURELY or CHANGE IT IMMEDIATELY AFTER LOGIN."
echo "=========================================================="
echo ""


# Clean up the temporary secrets file
echo "Helm deployment finished. Cleaning up temporary secrets file..."
rm -f "$TEMP_SECRETS_FILE"

echo "Superset deployment process complete."
echo "You can verify the secrets created in Kubernetes using commands like:"
echo "  kubectl get secret -n superset superset-superset-env -o yaml"
echo "  kubectl get secret -n superset superset-superset-config -o yaml"
echo "(Remember to base64 decode values if you inspect the raw secret YAML)"
echo "To access Superset in Minikube, you might use 'minikube service superset -n superset'."
echo

export NODE_PORT=$(kubectl get --namespace superset -o jsonpath="{.spec.ports[0].nodePort}" services superset)
export NODE_IP=$(kubectl get nodes --namespace superset -o jsonpath="{.items[0].status.addresses[0].address}")
echo http://$NODE_IP:$NODE_PORT
echo


# Postgrest
kubectl apply -f deploy-postgrest.yaml --namespace superset
kubectl get --namespace superset services

# kubectl delete service postgrest-service --namespace superset
# kubectl delete deployment postgrest-deployment --namespace superset


